<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js canvas - interactive - voxel painter</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            margin: 0px;
            overflow: hidden;
        }
    </style>
</head>

<body>

    <script src="lib/three.js"></script>
    <script src="lib/leap-0.6.4.js"></script>
    <script src="lib/leap-plugins-0.1.6.js"></script>

    <script src="lib/renderers/Projector.js"></script>
    <script src="lib/renderers/CanvasRenderer.js"></script>

    <script>
        var container;
        var camera, scene, renderer;
        var plane;

        var mouse, raycaster, isShiftDown = false;

        var cubeGeometry = new THREE.BoxGeometry(30, 30, 5);
        var cubeMaterial = new THREE.MeshLambertMaterial({
            color: 0xff0000,            
        });

        var objects = [];

        var colors = [0xff0000, 0x00ff00, 0x0000ff];
        var baseBoneRotation = (new THREE.Quaternion).setFromEuler(
            new THREE.Euler(Math.PI / 2, 0, 0)
            );

        var translationPoint = [0, 0, 0];
        var speedPoint = [1, 1, 1];

        function translatePoint(pos, translation, speed)
        {
            pos[0] = (pos[0] + translation[0])*speed[0];
            pos[1] = (pos[1] + translation[1])*speed[1];
            pos[2] = (pos[2] + translation[2])*speed[2];

            return pos;
        }

        var controller = Leap.loop({
            background: false,
            enableGestures: false,
        }, {
            hand: function(hand) {
                var fingersUp = true;
                var indexPointing = false;
                var indexPointingX = 0.0;
                var indexPointingY = 0.0;

                    //console.log("Interaction box height : " + this.lastFrame.interactionBox	);
                    IB = this.lastFrame.interactionBox;
                    //translationPoint[0] = IB.width;
                    speedPoint[0] = (renderer.domElement.clientWidth/IB.width);
                    speedPoint[1] = (renderer.domElement.clientHeight/IB.height);
                    translationPoint[1] = -1*IB.height;
                    //translationPoint[2] = IB.height;


                    hand.fingers.forEach(function(finger) {

                        // This is the meat of the example - Positioning `the cylinders on every frame:
                        finger.data('boneMeshes').forEach(function(mesh, i) {
                            var bone = finger.bones[i];                                                        

                            mesh.position.fromArray(translatePoint(bone.center(), translationPoint, speedPoint));
                            
                            mesh.setRotationFromMatrix(
                                (new THREE.Matrix4).fromArray(bone.matrix())
                                );

                            mesh.quaternion.multiply(baseBoneRotation);

                        });

                        finger.data('jointMeshes').forEach(function(mesh, i) {
                            var bone = finger.bones[i];                            

                            if (bone) {
                                mesh.position.fromArray(translatePoint(bone.prevJoint, translationPoint, speedPoint));
                            } else {
                                // special case for the finger tip joint sphere:
                                bone = finger.bones[i - 1];                            	
                                mesh.position.fromArray(translatePoint(bone.nextJoint, translationPoint, speedPoint));
                            }

                            if(finger.type == 1 && bone.type == 3)
                                console.log("finger center : " + bone.nextJoint);


                            if (finger.type != 0 && bone.type == 3 && bone.direction()[1] < 0.0) {
                                fingersUp = false;
                            }
                            if (finger.type == 1 && bone.type == 3 && bone.direction()[1] > 0.0) {
                                indexPointing = true;                                
                                //indexPointingX = IB.normalizePoint(translatePoint(bone.nextJoint, translationPoint, speedPoint))[0];
                                //indexPointingY = IB.normalizePoint(translatePoint(bone.nextJoint, translationPoint, speedPoint))[1];
                                indexPointingX = IB.normalizePoint(bone.nextJoint)[0];
                                indexPointingY = IB.normalizePoint(bone.nextJoint)[1];
                            }
                        });
                    });

                    
                    if (fingersUp) {
                        true;
                        //console.log("[Gesture] Hand : " + hand.id + " with all fingers up.");
                    }
                    if (!fingersUp && indexPointing) {
                        //console.log("[Gesture] Hand : " + hand.id + " index pointing.");
                        index_x = indexPointingX;
                        index_y = indexPointingY;
                        //console.log("index pointing at x: " + index_x +", y: " + index_y);
                        mouse.x = index_x;
                        mouse.y = index_y;


                        raycaster.setFromCamera(mouse, camera);

                        var intersects = raycaster.intersectObjects(objects);

                        if (intersects.length > 0 ) {
                        	
                            var intersect = intersects[0];            
                            if (hand.type == "left") {

                                if (intersect.object != plane) {

                                    scene.remove(intersect.object);

                                    objects.splice(objects.indexOf(intersect.object), 1);

                                }

                            } else if(hand.type == "right" && intersects[0].point.z == 0) {                                
                                var voxel = new THREE.Mesh(cubeGeometry, cubeMaterial);
                                intersectPoint = [hand.fingers[1].bones[3].nextJoint[0], hand.fingers[1].bones[3].nextJoint[1], hand.fingers[1].bones[3].nextJoint[2]];
                                
                                console.log(intersectPoint);
                                voxel.position.fromArray(intersectPoint);
                                voxel.position.divideScalar(30).floor().multiplyScalar(30).addScalar(5);
                                scene.add(voxel);

                                objects.push(voxel);

                            }

                            render();

                        }
                    }
                    
                    
                    //camera.position.set(0, 0, 400+hand.arm.center()[2]);

                    /*var armMesh = hand.data('armMesh');
                    hand.arm.center()[1] /= 5;
                    armMesh.position.fromArray(hand.arm.center());

                    armMesh.setRotationFromMatrix(
                        (new THREE.Matrix4).fromArray(hand.arm.matrix())
                    );

                    armMesh.quaternion.multiply(baseBoneRotation);

                    armMesh.scale.x = hand.arm.width / 2;
                    armMesh.scale.z = hand.arm.width / 4;
                    */

                    renderer.render(scene, camera);

                }
            })
            // these two LeapJS plugins, handHold and handEntry are available from leapjs-plugins, included above.
            // handHold provides hand.data
            // handEntry provides handFound/handLost events.
            .use('handHold')
            .use('handEntry')
            .on('handFound', function(hand) {

                hand.fingers.forEach(function(finger) {

                    var boneMeshes = [];
                    var jointMeshes = [];

                    /*finger.bones.forEach(function(bone) {
                        // create joints

                        // CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)
                        var boneMesh = new THREE.Mesh(
                            new THREE.CylinderGeometry(5, 5, bone.length),
                            new THREE.MeshPhongMaterial()
                        );

                        boneMesh.material.color.setHex(0xffffff);
                        scene.add(boneMesh);
                        boneMeshes.push(boneMesh);

                    });*/

                    for (var i = 0; i < finger.bones.length + 1; i++) {

                        var jointMesh = new THREE.Mesh(
                            new THREE.SphereGeometry(10),
                            new THREE.MeshPhongMaterial()
                            );
                        if(finger.type == 1 && i==4)
                            jointMesh.material.color.setHex(0xff0000);
                        else
                            jointMesh.material.color.setHex(0x0088ce);
                        scene.add(jointMesh);
                        jointMeshes.push(jointMesh);

                    }

                    finger.data('boneMeshes', boneMeshes);
                    finger.data('jointMeshes', jointMeshes);

                });

                /*if (hand.arm) { // 2.0.3+ have arm api,
                    // CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments, heightSegments, openEnded)
                    var armMesh = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.5, 0.5, hand.arm.length, 16),
                        new THREE.MeshPhongMaterial()
                    );

                    armMesh.material.color.setHex(0xffffff);

                    scene.add(armMesh);

                    hand.data('armMesh', armMesh);

                }*/

            })
            .on('handLost', function(hand) {

                hand.fingers.forEach(function(finger) {

                    var boneMeshes = finger.data('boneMeshes');
                    var jointMeshes = finger.data('jointMeshes');

                    boneMeshes.forEach(function(mesh) {
                        scene.remove(mesh);
                    });

                    jointMeshes.forEach(function(mesh) {
                        scene.remove(mesh);
                    });

                    finger.data({
                        boneMeshes: null,
                        boneMeshes: null
                    });

                });

                var armMesh = hand.data('armMesh');
                scene.remove(armMesh);
                hand.data('armMesh', null);

                renderer.render(scene, camera);

            })
            .on('connect', function() {

            });




            init();
            render();

            function init() {

                container = document.createElement('div');
                document.body.appendChild(container);

                var info = document.createElement('div');


                camera = new THREE.PerspectiveCamera(100, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(0, 0, 400);
                camera.lookAt(new THREE.Vector3());

                scene = new THREE.Scene();

            // Grid

            var size = 300,
            step = 30;

            var geometry = new THREE.Geometry();

            for (var i = -size; i <= size; i += step) {

                geometry.vertices.push(new THREE.Vector3(-size, i, 0));
                geometry.vertices.push(new THREE.Vector3(size, i, 0));

                geometry.vertices.push(new THREE.Vector3(i, -size, 0));
                geometry.vertices.push(new THREE.Vector3(i, size, 0));

            }

            var material = new THREE.LineBasicMaterial({
                color: 0xf0f0f0,
                opacity: 0.2
            });

            var line = new THREE.LineSegments(geometry, material);
            scene.add(line);

            //

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            var geometry = new THREE.PlaneBufferGeometry(600, 600);
            

            plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
                visible: false
            }));
            scene.add(plane);

            var squareGeometry = new THREE.Geometry(); 
            squareGeometry.vertices.push(new THREE.Vector3(-50.0,  50.0, 0.0)); 
            squareGeometry.vertices.push(new THREE.Vector3( 50.0,  50.0, 0.0)); 
            squareGeometry.vertices.push(new THREE.Vector3( 50.0, -50.0, 0.0)); 
            squareGeometry.vertices.push(new THREE.Vector3(-50.0, -50.0, 0.0)); 
            squareGeometry.faces.push(new THREE.Face3(0, 1, 2)); 
            squareGeometry.faces.push(new THREE.Face3(0, 2, 3)); 

            var squareMaterialRed = new THREE.MeshBasicMaterial({ 
              color:0xff00000, 
              side:THREE.DoubleSide 
          }); 
            var squareMaterialGreen = new THREE.MeshBasicMaterial({ 
              color:0x00ff00, 
              side:THREE.DoubleSide 
          }); 
            var squareMaterialBlue = new THREE.MeshBasicMaterial({ 
              color:0x0000ff, 
              side:THREE.DoubleSide 
          }); 

            var squareMeshRed = new THREE.Mesh(squareGeometry, squareMaterialRed); 
            var squareMeshGreen = new THREE.Mesh(squareGeometry, squareMaterialGreen); 
            var squareMeshBlue = new THREE.Mesh(squareGeometry, squareMaterialBlue);
            squareMeshRed.position.set(400, 0.0, 0.0); 
            squareMeshGreen.position.set(400, 100, 0.0); 
            squareMeshBlue.position.set(400, -100.0, 0.0); 
            scene.add(squareMeshRed); 
            scene.add(squareMeshGreen); 
            scene.add(squareMeshBlue); 



            objects.push(plane);
            objects.push(squareMeshRed);
            objects.push(squareMeshGreen);
            objects.push(squareMeshBlue);

            var material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                wireframe: true
            });

            // Lights

            var ambientLight = new THREE.AmbientLight(0x606060);
            scene.add(ambientLight);

            var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0, 0.5, 1);
            window.scene.add(directionalLight);


            renderer = new THREE.CanvasRenderer();
            renderer.setClearColor(0x000000, 1);  // black
            // white : renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            
            //
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener( 'mousedown', onDocumentMouseDown, false );


        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

            render();

        }

        function onDocumentMouseDown(event) {

            event.preventDefault();

            mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
            mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;


            //console.log("event mouse click at x: " + event.clientX +", y: " + event.clientY);
            //console.log("mouse click at x: " + mouse.x +", y: " + mouse.y);

            raycaster.setFromCamera(mouse, camera);

            var intersects = raycaster.intersectObjects(objects);

            if (intersects.length > 0 && intersects[0].point.z < 30) {

                var intersect = intersects[0];
                console.log(intersect);

                if (isShiftDown) {

                    if (intersect.object != plane) {

                        scene.remove(intersect.object);

                        objects.splice(objects.indexOf(intersect.object), 1);

                    }

                } else {

                    var voxel = new THREE.Mesh(cubeGeometry, cubeMaterial);
                    voxel.position.copy(intersect.point).add(intersect.face.normal);
                    voxel.position.divideScalar(30).floor().multiplyScalar(30).addScalar(15);
                    scene.add(voxel);

                    objects.push(voxel);

                }

                render();

            }

        }

        function render() {

            renderer.render(scene, camera);

        }
    </script>

</body>

</html>